== Architecture

=== Execution Flow

image::denovm-execution-sequence.png[DenoVM Execution Flow, 1000, align="center"]

=== Detailed Flow

image::denovm-detailed-flow.png[DenoVM Complete Execution Flow, 1200, align="center"]

=== System Components

[cols="30,70",options="header"]
|===
|Component |Purpose

|`DenoVMService`
|Main entry point - accepts requests and returns results

|`ExecutionStrategyFactory`
|Selects single-run or pool mode based on configuration

|`SingleExecutionStrategy`
|Creates new Deno process per request

|`PoolExecutionStrategy`
|Uses persistent worker pool for requests

|`DenoWorkerPool`
|Manages pool of Deno workers

|`DenoWorker`
|Individual persistent Deno process
|===

=== Worker Lifecycle

Workers transition: **Creating** → **Idle** → **Busy** → **Recycling/Failed** → **Terminated**

Auto-recycle after `pool-max-tasks-per-worker` tasks or when idle for `pool-idle-kill-seconds`.

=== Error Handling

[cols="25,30,45",options="header"]
|===
|Error Type |Behavior |Solution

|Script error
|`DenoVMResult.success=false`
|Check error message, validate script

|Timeout
|`DenoVMResult.error="VM execution timeout"`
|Increase `timeout-seconds`

|Worker failure
|`DenoWorkerException` thrown
|Worker auto-replaced; retry

|Pool failure
|`DenoWorkerPoolException` thrown
|Check Deno installation
|===

=== Security

* Isolated Deno processes per worker
* Automatic temp file cleanup
* Network/file permissions via Deno flags
* No JVM memory access from JavaScript
